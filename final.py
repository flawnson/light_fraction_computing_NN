# -*- coding: utf-8 -*-
"""Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1_7WpdxECK-VI6yGdgmRwoKfIWXqgm5So
"""

import numpy as np
import cv2 as cv
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
from PIL import Image
import os
import math
import matplotlib.patches as mpatches
from skimage import data
from skimage.filters import threshold_mean
from skimage.segmentation import clear_border
from skimage.measure import label, regionprops
from skimage.morphology import closing, square
from skimage.color import label2rgb
from flask import jsonify
from flask import send_file
from io import BytesIO
from flask import make_response, Flask, request
app = Flask(__name__)


from flask import Flask, request
#from flask_restful import Resource, Api

def ratioBW(fileName):
    with app.app_context():
        #converting image to array
        img = Image.open(fileName).convert('1')
        imgArr = np.array(img);
        
        #making it 1D
        flatArr = imgArr.ravel()
        
        #calculating ratios
        total = len(flatArr)
        white = np.sum(flatArr)
        black = total - white
         
        #Return [white, black, total]
        return [white, black, total]    

    
    
def ratioBWImported(fileName):
    with app.app_context():

        #converting image to array
        img = Image.open(fileName).convert('1')
        imgArr = np.array(img);
        
        #making it 1D
        flatArr = imgArr.ravel()
        
        #calculating ratios
        total = len(flatArr) - 53369
        white = np.sum(flatArr) - 53369
        black = total - white
         
        #Return [white, black, total]
        return [white, black, total]    

def labelsInv(path):
    with app.app_context():
      image = cv.imread(path, 0)
      ret, image = cv.threshold(image, 0, 255, cv.THRESH_TOZERO_INV + cv.THRESH_OTSU )

      #Track labels
      numLabel = 0
      labelRegion = []

      # apply threshold
      thresh = threshold_mean(image)
      bw = closing(image > thresh, square(3))

      # remove artifacts connected to image border
      cleared = clear_border(bw)

      # label image regions
      label_image = label(cleared)
      image_label_overlay = label2rgb(label_image, image=image)

      fig, ax = plt.subplots(figsize=(10, 6))
      ax.imshow(image_label_overlay)

      for region in regionprops(label_image):
          # take regions with large enough areas
          if region.area >= 100:
            # draw rectangle around segmented coins
            minr, minc, maxr, maxc = region.bbox
            rect = mpatches.Rectangle((minc, minr), maxc - minc, maxr - minr,
                                      fill=False, edgecolor='red', linewidth=2)
            ax.add_patch(rect)

            labelRegion.append(region.area)
            numLabel = numLabel + 1

      ax.set_axis_off()
      plt.tight_layout()
      plt.show()

      return [numLabel, labelRegion]
  
      print(numLabel)
  
def labels(path):
  with app.app_context():
    image = cv.imread(path, 0)

    #Track labels
    labelRegion = []
    numLabel = 0

    # apply threshold
    thresh = threshold_mean(image)
    bw = closing(image > thresh, square(3))

    # remove artifacts connected to image border
    cleared = clear_border(bw)

    # label image regions
    label_image = label(cleared)
    image_label_overlay = label2rgb(label_image, image=image)

    fig, ax = plt.subplots(figsize=(10, 6))
    ax.imshow(image_label_overlay)

    for region in regionprops(label_image):
        # take regions with large enough areas
        if region.area >= 100:
          # draw rectangle around segmented coins
          minr, minc, maxr, maxc = region.bbox
          rect = mpatches.Rectangle((minc, minr), maxc - minc, maxr - minr,
                                    fill=False, edgecolor='red', linewidth=2)
          ax.add_patch(rect)

          labelRegion.append(region.area)
          numLabel = numLabel + 1

    ax.set_axis_off()
    plt.tight_layout()
    plt.show()

    return [numLabel, labelRegion]
   
def avgSize(numGrain):
  with app.app_context():
    avgSize = 78400/numGrain

    r = math.sqrt(avgSize/3.14159)
    surfaceArea = 4*3.14159*r*r

    return [r*2,avgSize,surfaceArea]

def histogram(label, labelInv):
  with app.app_context():
    img = BytesIO()
    arr = label + labelInv
    arrArea = []

    for i in range(len(arr)):
        r = math.sqrt(arr[i]/3.14159)
        surfaceArea = 4*3.14159*r*r
        arrArea.append(surfaceArea)

    arrArea = np.array(arrArea)    
    plt.hist(arrArea, bins='auto')
    plt.title('Surface Areas of Grains')
    plt.xlabel('Area in Pixels')
    plt.ylabel('Number of Grains')
    plt.savefig(img, format='png', dpi=300, pad_inches=None, bbox_inches='tight')
    plt.show()
    img.seek(0)

    response=make_response(img.getvalue())
    response.headers['Content-Type'] = 'image/png'
    img.close()
    return response
  
  

def thesholdBin(filename):
  with app.app_context():

    img = cv.imread(filename, 0)
    
    th = 0
    max_val = 255
    
    #for challenge 3 pre preparing
    ret, o6 = cv.threshold(img, th, max_val, cv.THRESH_BINARY + cv.THRESH_OTSU )
    ret, o7 = cv.threshold(img, th, max_val, cv.THRESH_BINARY_INV + cv.THRESH_OTSU )
    ret, o8 = cv.threshold(img, th, max_val,  cv.THRESH_TOZERO_INV + cv.THRESH_OTSU )
    
    output = [o6,o7,o8]

        
    
    plt.subplot(2, 4, 1)
    plt.imshow(output[0], cmap='gray')
    plt.xticks([])
    plt.yticks([])
    plt.savefig('my'+str(1)+'.png', dpi=300, pad_inches=None, bbox_inches='tight')
    plt.show() 
    
    plt.subplot(2, 4, 2)
    plt.imshow(output[1], cmap='gray')
    plt.xticks([])
    plt.yticks([])
    plt.savefig('my'+str(2)+'.png', dpi=300, pad_inches=None, bbox_inches='tight')
    plt.show() 
    
    plt.subplot(2, 4, 2)
    plt.imshow(output[2], cmap='gray')
    plt.xticks([])
    plt.yticks([])
    plt.savefig('my'+str(3)+'.png', dpi=300, pad_inches=None, bbox_inches='tight')
    plt.show() 
  

def mainFunc(fileSel, numSel):
  fileName = fileSel #input('Enter The File Name Of The Image: ')
  #print('Menu: \n 1) Fraction of Dark Phase \n 2)Fraction of Dark Phase (Noisy)')
  #print(' 3) Fraction of Dark Phase (Gradient) \n 4) Avg Grain Surface Area \n 5) Histogram')
  sel = numSel #int(input("Selection: "))
  
  
  if sel == 1:
    with app.app_context():
      result = ratioBW(fileName)
      print(str((result[1]/result[2])*100) + '% is black')
      return jsonify(str((result[1]/result[2])*100) + '% is black')
    
  elif sel == 2:
    with app.app_context():
      thesholdBin(fileName)
      result = ratioBWImported('my1.png')
      print(str((result[1]/result[2])*100) + '% is black')
      return jsonify(str((result[1]/result[2])*100) + '% is black')
  
  elif sel == 3:
    with app.app_context():
      thesholdBin(fileName)
      result1 = ratioBWImported('my1.png')
      result2 = ratioBWImported('my3.png')
      print(str((((78400-result1[0])+(78400-result2[0]))/78400)*100) + '% is black')    
      return jsonify(str((((78400-result1[0])+(78400-result2[0]))/78400)*100) + '% is black')
    
  elif sel == 4:
    with app.app_context():
      numLabel = labels(fileName)[0] + labelsInv(fileName)[0]
      print(str(avgSize(numLabel)[0]) + ' is the diameter and ' + str(avgSize(numLabel)[2]) + ' is the surface area in pixels')
      return jsonify(str(avgSize(numLabel)[0]) + ' is the diameter and ' + str(avgSize(numLabel)[2]) + ' is the surface area in pixels')
    
  elif sel == 5:
    try:
      return histogram(labels(fileName)[1], labelsInv(fileName)[1])
    except Exception as e:
      print(str(e))
    
    


    
  else: 
    print('Error: Image Not Found Or Selection of ${sel} Out Of Range')

@app.route('/<path:fileSel>/<int:numSel>', methods = ['POST'])
def run():
  
  if request.method == 'POST':
    return mainFunc(request.form['fileSel'],request.form['numSel'])

if __name__ == '__main__':
  app.run(host='127.0.0.1', port=5000)